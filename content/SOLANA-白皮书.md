---
title: Solana-白皮书
---
```yaml
url:
  - en: https://github.com/solana-labs/whitepaper/blob/master/solana-whitepaper-en.pdf
  - zh: https://jiami.one/solana-whitepaper-chinese-version/
```

本⽂提出了⼀种基于历史证明（PoH）的新的区块链架构—⼀种⽤于验证事件之间的顺序和时间流逝的证明。PoH ⽤于将不受信任的时间流逝编码到账本中 – 这是⼀种只会累加的数据结构。当与⼯作量证明 (PoW) 或权益证明 (PoS) 等共识算法⼀起使⽤时，PoH 可以减少实用拜占庭容错算法的消息传递开销，从⽽实现亚秒级确定。本文还提出了两种利用时间保持PoH账本属性的算法——⼀种可以从任何⼤⼩的分区中恢复的 PoS 算法和⼀种⾼效的流式复制证明 (PoRep)。在时间排序和存储⽅⾯，PoRep 和PoH 的组合提供了对账本伪造的防御。 本文是基于1gbps的网络上分析的，表明以当前的硬件水平，吞吐量高达710k txn/秒是可以实现的。

## 1 简介

区块链使用复制状态机的方式来解决容错的问题。当前公开可⽤的区块链不依赖于时间，或者对参与者保持时间的能⼒做出弱假设[4, 5]。⽹络中的每个节点通常依赖于他们⾃⼰的本地时钟，⽽不知道⽹络中任何其他参与者的时钟。缺乏可信的时间来源意味着当使⽤消息时间戳来接受或拒绝消息时，⽆法保证⽹络中的每个其他参与者都会做出完全相同的选择。本文介绍的 PoH 就是为了创建具有可验证时间流逝（指事件的持续时间和消息排序）的账本。预计⽹络中的每个节点都将能够在没有信任的情况下依赖账本中记录的时间流逝。

### Related articles

[

![Flow公链白皮书中文版](https://jiami.one/wp-content/uploads/2024/04/image-11-120x86.png)

](https://jiami.one/flow-whitepaper-chinese-version/)

### [Flow公链白皮书中文版](https://jiami.one/flow-whitepaper-chinese-version/)

 [2024-04-29](https://jiami.one/flow-whitepaper-chinese-version/)

[

![以太坊白皮书中文版](https://jiami.one/wp-content/uploads/2024/04/image-3-120x86.png)

](https://jiami.one/etherum-whitepaper-chinese-version/)

### [以太坊白皮书中文版](https://jiami.one/etherum-whitepaper-chinese-version/)

 [2024-04-29](https://jiami.one/etherum-whitepaper-chinese-version/)

## 2 ⼤纲

本⽂的其余部分组织如下。

第3章描述了整体系统设计

第4章深入描述了历史证明

第5章深入描述了股权证明共识算法

第6章深入描述了提议的快速复制证明

第7章深入描述了系统架构和性能限制

## 3 ⽹络设计

见图 1，在任何时间，都有一个系统节点被指定为Leader⽣成历史证明序列，提供⽹络全局读取⼀致性和可验证的时间流逝。Leader 对⽤⼾消息进⾏排序和排序，以便系统中的其他节点可以有效地处理它们，从⽽最⼤限度地提⾼吞吐量。它在存储在 RAM 中的当前状态上执⾏交易，并将交易和最终状态的签名发布到称为Verifier的验证节点。验证者在他们的状态副本上执⾏相同的交易，并发布他们计算出的状态签名作为确认。他们公布的确认消息作为共识算法的投票。

[![](https://jiami.one/wp-content/uploads/2024/04/image-4-1024x626.png)](https://jiami.one/wp-content/uploads/2024/04/image-4.png)

_图1:整个网络的交易流_

在⾮分区状态下的任何时间内，⽹络中都有⼀个Leader。每个 Verifier 节点都具有与 Leader 相同的硬件能⼒，并且可以通过基于 PoS 的选举成为 Leader。这个基于 PoS 算法的选举在5.6中有详细介绍。

## 4 **Proof of History 历史证明**

历史证明是通过一个计算生成的序列，来提供⼀种加密验证两个事件之间的时间流逝的⽅法。它使⽤加密函数生成序列，因此⽆法从各个序列的输⼊预测最终输出，必须完全执⾏才能⽣成输出。该函数在单个内核上按顺序运⾏，前者的输出结果作为当前计算的输⼊参数，定期记录当前输出，这些输出的记录可以被外部计算机的计算机重新计算和验证。

通过将数据（或数据的hash）附加到加密函数的state(理解成函数入参)中，数据可以在该序列中打上时间戳。当state、index和数据被附加到序列中时，它的记录提供了一个时间戳，可以保证数据是在序列⽣成下⼀个hash之前的某个时间创建的。这种设计还⽀持⽔平缩放，因为多个⽣成器可以通过将它们的state混合到彼此的序列中来相互同步。⽔平缩放在4.4中有深⼊介绍。

### 4.1 说明

本系统的工作原理如下。通过使⽤hash加密函数，如果不运⾏该函数就⽆法预测其输出（例如 sha256、ripemd等），从某个随机起始值运⾏该函数并获取其输出并将其作为输⼊再次传递给同⼀个函数。记录函数被调⽤的次数和每次调⽤的输出。选择的起始随机值可以是任何字符串，例如当天纽约时报的标题。

例如：

|PoH Sequence|||
|---|---|---|
|Index|Operation|Output Hash|
|1|sha256(“any random starting value”)|hash1|
|2|sha256(hash1)|hash2|
|3|sha256(hash2)|hash3|

哈希N 表示实际的哈希输出。

只需要每隔⼀段时间发布hash和index的⼦集。

例如：

|PoH Sequence|||
|---|---|---|
|Index|Operation|Output Hash|
|1|sha256(“any random starting value”)|hash1|
|200|sha256(hash199)|hash200|
|300|sha256(hash299)|hash300|

只要选择的哈希函数是抗碰撞的，这组哈希就只能由计算机单线程按顺序计算。这是因为如果不从起始值实际运⾏算法 300 次，就⽆法预测index 300 处的哈希值将是什么。因此我们可以从数据结构中推断出在index 0 和index 300 之间存在时间流逝。

见图 2, 哈希值 62f51643c1 在计数 510144806912产生的， 哈希值 c43d862d88 是在计数 510146904064 上产⽣的。根据前⾯讨论的 PoH 算法的特性，我们可以相信在计数 510144806912 和计数 510146904064 之间存在时间流逝。

[![](https://jiami.one/wp-content/uploads/2024/04/image-5.png)](https://jiami.one/wp-content/uploads/2024/04/image-5.png)

_图 2：历史序列证明_

### 4.2 事件时间戳

此哈希序列还可⽤于记录在⽣成特定hash n之前创建的某些数据。使⽤“combine”函数将数据与当前index处的hash组合起来，组合的数据可以简化为数据的hash值。“combine”函数可以是简单的数据拼接，也可以是任何抗碰撞操作。下⼀个⽣成的哈希值表⽰数据的时间戳，因为它只能在插⼊特定数据后⽣成的。

例如：

|PoH Sequence|||
|---|---|---|
|Index|Operation|Output Hash|
|1|sha256(“any random starting value”)|hash1|
|200|sha256(hash199)|hash200|
|300|sha256(hash299)|hash300|

发⽣了⼀些外部事件，例如拍摄照⽚或创建了任意数据：

|PoH Sequence With Data|||
|---|---|---|
|Index|Operation|Output Hash|
|1|sha256(“any random starting value”)|hash1|
|200|sha256(hash199)|hash200|
|300|sha256(hash299)|hash300|
|336|sha256(append(hash335, photograph sha256))|hash336|

hash336 通过拼接的 hash335 和 照⽚的sha256 计算而出的。index和 照⽚的sha256 被记录为序列输出的⼀部分。因此，任何验证此序列的⼈都可以复现这个结果，而且验证过程可以并行，此部分在4.3有介绍。

因为初始过程仍然是顺序的，所以我们可以判断输⼊到序列中的事情⼀定是在计算未来hash值之前的某个时间发⽣的。

|POH Sequence|||
|---|---|---|
|Index|Operation|Output Hash|
|1|sha256(“any random starting value”)|hash1|
|200|sha256(hash199)|hash200|
|300|sha256(hash299)|hash300|
|336|sha256(append(hash335, photograph1 sha256))|hash336|
|400|sha256(hash399)|hash400|
|500|sha256(hash499)|hash500|
|600|sha256(append(hash599, photograph2 sha256))|hash600|
|700|sha256(hash699)|hash700|

表 1：具有 2 个事件的 PoH 序列

在表1所表⽰的序列中 , 照⽚2 在hash600之前创建，照⽚1 在hash336之前创建。 将数据插⼊hash序列会导致序列中所有后续值发⽣更改。只要所使⽤的hash函数是抗碰撞的，并且数据是附加的，就应该不可能预先计算任何未来的序列。

添加到序列中的数据可以是原始数据本⾝，也可以是原数据的hash值。

见图3， 输⼊ cfd40df8… 被插⼊到历史证明序列中。它被插⼊的count是 510145855488，它被插⼊的状态是3d039eef3。 所有未来⽣成的hash都通过对序列的这种变化进⾏修改，这种变化由图中的颜⾊变化表⽰。

观察这个序列的每个节点都可以确定所有事件插⼊的顺序并估计插⼊之间的真实时间。

[![](https://jiami.one/wp-content/uploads/2024/04/image-6.png)](https://jiami.one/wp-content/uploads/2024/04/image-6.png)

_图 3：将数据插⼊历史证明_

### 4.3 验证

多核计算机验证序列时所需的时间比生成序列要少很多。

例如：

|Core 1|||
|---|---|---|
|Index|Data|Output Hash|
|200|sha256(hash199)|hash200|
|300|sha256(hash299)|hash300|

|Core 2|||
|---|---|---|
|Index|Data|Output Hash|
|300|sha256(hash299)|hash300|
|400|sha256(hash399)|hash400|

给定⼀定数量的内核，比如具有 4000 个内核的现代 GPU，验证器可以将哈希序列及其索引拆分为 4000 个切⽚，并确保每个切⽚从起始哈希到最后⼀个哈希都是正确的⽚。

⽣成序列的预期时间=hash总数单内核1s内处理的hash数⽣成序列的预期时间 = \frac{ hash总数}{单内核1s内处理的hash数}⽣成序列的预期时间=单内核1s内处理的hash数hash总数​

验证序列的预期时间=hash总数单内核1s内处理的hash数∗可验证的核数验证序列的预期时间 = \frac{ hash总数}{单内核1s内处理的hash数 * 可验证的核数}验证序列的预期时间=单内核1s内处理的hash数∗可验证的核数hash总数​

[![](https://jiami.one/wp-content/uploads/2024/04/image-7.png)](https://jiami.one/wp-content/uploads/2024/04/image-7.png)

_图 4：使⽤多核进⾏验证_

见图4，每个内核都能够并⾏验证序列的每个切⽚。由于所有输⼊字符串都记录到输出中，并带有附加到它们的计数器和状态，因此验证器可以并⾏复制每个切⽚。红⾊hash表⽰序列被数据插⼊而导致修改。

### 4.4 ⽔平缩放

可以通过将每个⽣成器的序列状态混合到其他⽣成器来同步多个历史证明⽣成器，从⽽实现历史证明⽣成器的⽔平缩放。这种缩放无需分片即可完成。两个⽣成器的输出对于重建系统中事件的完整顺序是必要的。

|PoH Generator A|||PoH Generator B|||
|---|---|---|---|---|---|
|Index|Hash|Data|Index|Hash|Data|
|1|hash1a||1|hash1b||
|2|hash2a|hash1b|2|hash2b|hash1a|
|3|hash3a||3|hash3b||
|4|hash4a||4|hash4b||

给定⽣成器 A 和 B，A 从 B (hash1b) 接收⼀个数据包，其中包含来⾃⽣成器 B 的最后⼀个状态。⽣成器 A 中的下⼀个状态哈希取决于来⾃⽣成器的⽣成器 B的状态，因此我们可以推导出 hash1b 发⽣在 hash3a 之前的某个时间。此属性可以传递，因此如果三个⽣成器通过单个公共⽣成器同步_A ↔ B ↔ C_，我们可以追踪 A 和 C 之间的依赖关系，即使它们没有直接同步。

通过定期同步⽣成器，每个⽣成器然后可以处理⼀部分外部流量，因此整个系统可以处理⼤量事件以进⾏跟踪，但代价是由于⽣成器之间的⽹络延迟⽽导致的真实时间准确性。

见图 5，两台生成器互相插⼊输出状态并记录运⾏情况。颜⾊变化表明来⾃对等⽅的数据修改了序列。混合到每个流中的⽣成hash以粗体突出显⽰。

同步是可传递的。 在 A 和 C 到 B 之间存在可证明的事件顺序。

以这种⽅式扩展是以牺牲可⽤性为代价的。10_×_ 1 gbps 连接按照0.999的可用性计算，将有0 _._ 999的10次方，也就是约0.99的可⽤性。

[![](https://jiami.one/wp-content/uploads/2024/04/image-8.png)](https://jiami.one/wp-content/uploads/2024/04/image-8.png)

_图 5：两台生成器同步_

### 4.5 ⼀致性

用户希望能够通过插入最后一个观察到的输出(在他们认为有效的序列里) 插入到他们输入中来，以增强一致性，并使其能够抵抗攻击。

|PoH Generator A||PoH Generator B||||
|---|---|---|---|---|---|
|Index|Data|Output Hash|Index|Data|Output Hash|
|10||hash10a|10||hash10b|
|20|Event1|hash20a|20|Event3|hash20b|
|30|Event2|hash30a|30|Event2|hash30b|
|40|Event3|hash40a|40|Event1|hash40b|

如果恶意 PoH ⽣成器可以同时访问所有事件，或者能够⽣成更快的潜在序列，则它可以以相反的顺序⽣成带有事件的第⼆个潜在序列。

为了防⽌这种攻击，每个客⼾端⽣成的事件都应该包含客⼾端从它认为是有效序列中观察到的最新hash。因此，当客⼾端创建 Event1 数据时，他们应该附加他们观察到的最后⼀个哈希。

|PoH Generator A|||
|---|---|---|
|Index|Data|Output Hash|
|10||hash10a|
|20|Event1 = append(event1 data, hash10a)|hash20a|
|30|Event2 = append(event2 data, hash20a)|hash30a|
|40|Event3 = append(event3 data, hash30a)|hash40a|

当序列发布时，Event3 将引⽤ hash30a，如果 hash30a不在此事件之前的序列中，则序列的使⽤者知道它是⼀个⽆效序列。

为了防⽌恶意 PoH ⽣成器重写客⼾端事件哈希，客⼾端可以提交事件数据的签名和最后观察到的哈希，⽽不仅仅是数据。

|PoH Generator A|||
|---|---|---|
|Index|Data|Output Hash|
|10||hash10a|
|20|Event1 = sign(append(event1 data, hash10a), Client Private Key)|hash20a|
|30|Event2 = sign(append(event2 data, hash20a), Client Private Key)|hash30a|
|40|Event3 = sign(append(event3 data, hash30a), Client Private Key)|hash40a|

验证此数据需要签名验证，并在此之前的hash序列中查找该hash。

核实：

(Signature, PublicKey, hash30a, event3 data) = Event3

Verify(Signature, PublicKey, Event3)

Lookup(hash30a, PoHSequence)

见图 6，⽤⼾提供的输⼊依赖于hash 0xdeadbeef… 这个hash在插⼊之前，已经存在于⽣成的序列中。左上角的蓝⾊箭头表⽰客⼾端正在引⽤先前⽣成的hash。客⼾端消息仅在包含哈希0xdeadbeef….的序列中有效 序列中的红⾊表⽰该序列已被客⼾端数据修改。

[![](https://jiami.one/wp-content/uploads/2024/04/image-9.png)](https://jiami.one/wp-content/uploads/2024/04/image-9.png)

*图 6：具有反向引⽤的输⼊。 *

### 4.6 开销

每秒 4000 个hash将⽣成额外的 160 KB 数据，并且需要具有 4000 个内核的GPU花费⼤约 0.25-0.75 毫秒的时间来验证。

### **4.7 攻击**

#### **4.7.1 修改顺序**

⽣成反向顺序需要攻击者在第⼆个事件之后执行恶意的hash序列，但生成恶意序列期间，仍允许任何⾮恶意对等节点就原始订单进⾏通信。

#### 4.7.2 速度

拥有多个⽣成器可能会使部署更能抵抗攻击。⼀个生成器可以是⾼带宽的，并且接收许多事件以混合到它的序列中，另⼀个生成器可以是⾼速低带宽的，它周期性地与⾼带宽生成器混合。

高速序列将创建一个次级数据序列，攻击者将不得不撤销攻击。

#### 4.7.3 远程攻击

远程攻击是指攻击者获取了旧的废弃客⼾端私钥，并⽣成伪造的账本 [10]。历史证明提供了⼀些针对远程攻击的保护。获得旧私钥访问权限的恶意⽤⼾将不得不重新创建⼀个历史记录，该记录与他们试图伪造的原始记录花费的时间⼀样⻓。这将需要访问⽐⽹络当前使⽤的更快的处理器，否则攻击者将永远赶不上历史⻓度。

此外，单⼀的时间来源允许构建更简单的复制证明（更多内容在第 6）。由于⽹络的设计使得⽹络中的所有参与者都将依赖于事件的单⼀历史记录（就是Leader的）。

PoRep 和 PoH 应该⼀起提供针对伪造账本的空间和时间防御。

## 5 权益证明共识

### 5.1 说明

这个特定的权益证明实例旨在快速确认由历史证明⽣成器⽣成的当前序列，⽤于投票和选择下⼀个历史证明⽣成器，以及惩罚任何⾏为不端的验证器。该算法取决于消息最终在特定超时内到达所有参与节点。

### 5.2 术语

**bonds(质押)** **:** 债券相当于POW中的资本⽀出，比如⼀个矿⼯购买硬件和支付电费。**bonds**是验证者在验证交易时承诺作为抵押品的货币。

**slashing**: 在权益证明系统中提出的一个方案，违反协议规则的验证者可能会因丢失部分或全部权益（**bond**）。当发布不同分支的投票证明时，该分支可以销毁验证者的 **bond**。这是一种经济激励，为了阻止验证者确认多个分支，导致分叉。

**super majority:** 绝大多数指占持有总数 2/3 **bond** 的验证者。一个绝大多数投票表明网络已经达成共识，需要至少1/3的网络才能恶意投票使某一分支无效。这将使攻击的经济成本达到质押市值的1/3。

### 5.3 B**onding**质押

质押交易需要一定数量的货币，并把它转移到用户身份下的质押帐户。质押帐户中的货币不能直接使用，必须保留在帐户中，除非用户从质押账户中将他们移除。质押交易在经过绝大多数现有股东确认顺序后才有效。

### 5.4 投票

预计POH生成器将能够在预定的时间发布状态的签名。每个验证者必须通过发布自己的状态签名来确认这个签名。投票只有简单的赞成票，并没有反对票。

如果绝大多数验证者的在对应时间内投票，那么这个分支机构将被接受为有效。

### **5.5Unbonding 解除质押**

验证者缺少n个票数标志着质押的货币已经失效，不再有投票资格。用户可以发布’Unbonding’的Txn来移除它们。

n是基于 “过期选票/总选票” 的动态值。N随着过期选票数量的增加而增加。

### 5.6 选举

当发现 PoH 生成器出现问题时，就会选举新的 PoH 生成器。具有最⼤投票权的节点就会被被选为新的 PoH ⽣成器。

Leader生成新的序列需要经过持有绝⼤多数的质押股权（后续简称大多数）的验证节点确认，假如新的leader在绝大多数确认可⽤之前出现问题，就按股权质押权重的顺序，在验证节点中挑选另一位leader，同样，这一位Leader在生成新序列的时候也需要经过大多数质押股权的验证节点确认。

⼀旦建⽴了 PoH ⽣成器，就可以选择⼀个辅助节点来接管职责。 如果存在辅助节点，在leader 故障期时，这个辅助节点会被视为下⼀个leader。

### 5.7 选举触发机制

#### 5.7.1 POH 生成器分叉

PoH ⽣成器会对生成的序列签名，当同一个PoH身份发布了两个不同的历史序列，那就会检测到分叉。

#### 5.7.2 运⾏异常

出于硬件故障、bug或者故意的行为，POH生成器可能会生成与验证器结果不匹配的状态签名。

验证者将通过gossip发布正确的签名，这会触发新⼀轮选举。

任何赞成错误序列的验证者都会受到惩罚，削减其保证⾦。

#### 5.7.3 ⽹络超时

Leader节点⽹络超时将触发新的选举。

### 5.8 **Slashing 惩罚**

当验证者对两个单独的序列进⾏投票时，就会触发惩罚。如果存在验证节点恶意投票的证明，就会把节点质押的保证金扣除，放在矿池中去。

如果对 PoH ⽣成器⽣成的⽆效哈希进⾏投票，也会触发惩罚。⽣成器会随机⽣成⼀个⽆效状态，这会触发回退到辅助节点。

  

### 5.9 辅助节点选举

可以提议和批准辅助的POH生成器。这个提案是在主⽣成器序列上⽣成。这个提案具有一个超时时间，如果该提案在超时时间内以绝大多数通过，就会选举成功，并将按计划接管职责。

主⽣成器可以通过在生成的序列中插入一条消息来表示进行POH生成器的切换，也可以插入一个无效的状态并迫使网络回滚到到辅助生成器的状态。

如果选举了⼀个辅助节点，并且主节点当主节点出现问题时，在选举期间会优先考虑是否回滚到辅助节点的状态。

### 5.10 可⽤性

在CAP分区中，必须在一致性和可用性中选择一个，我们最终选择了可用性。

### 5.11 恢复

在这个系统中，账户可以在任何的故障中完全恢复。这意味着，世界上任何人都可以在账本中选择任意一点，通过添加新生成的哈希值和交易创建一个的分叉，但这个分支需要得到绝大多数的投票才能认定有效。

### 5.12 **Finality**

PoH 允许⽹络中的验证者观察过去发⽣的事情，并在⼀定程度上确定这些事件的时间。当 PoH ⽣成器⽣成消息流的时候，所有验证者都必须在 500ms 以内提交它的状态签名（投票）。这个时间可以根据⽹络状况进⼀步减少。由于所有的验证都进⼊POH序列中，所以⽹络中的每个⼈都查看各个验证者是否在要求的时间内提交了他们的投票。

### 5.13 攻击

#### 5.13.1 **Tragedy of Commons** 公地悲剧

PoS 验证者需要确认 PoH ⽣成器⽣成的状态哈希。有的验证节点就动了歪心思，想要躺平，比如他不做本地的任何计算和校验，直接批准所有⽣成的状态哈希。为了避免这种情况发生，PoH ⽣成器就会在某个时间随机注⼊⼀个⽆效的哈希值。所有给这个无效哈希投票的验证节点都会收到惩罚。当这个无效的哈希值生成后，就会把备用节点推选成新的 PoH ⽣成器。

每个验证者都需要在很短的时间内（比如500ms）做出响应 。超时时间应该设置得⾜够低，这种情况下，指望偷窥其他验证节点的投票去跟投的投机行为，就很难实施了。

### 5.13.2 与 PoH ⽣成器勾结

与 PoH ⽣成器勾结的验证者会提前知道何时会产⽣⽆效的哈希值，然后不投票。但这种情况，对于拥有超大质押股权的leader 没什么实质性的诱惑。leader任需要完成所有计算 ⼯作来⽣成状态哈希。