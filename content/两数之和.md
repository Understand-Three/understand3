---
title: 两数
---

# 目的

## 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

 

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**





# 不使用 hash map

1. 从第一个元素开始获取值
2. 目标值减去当前索引值
3. 如果差在vector里面，就去找这个值的索引，如果这个值的索引不是当前的 i ，就返回

```rust
module two_num::sum_of_two_numebr{

    use std::string;
    use std::string::String;
    use std::vector;
    use std::vector::{ index_of, contains};
    use aptos_std::debug;
    use aptos_std::string_utils;
    #[test_only]
    use std::vector::push_back;


    fun format_print(str_1:String,num_1:u64,str_2:String,num_2:u64){
        string::append(&mut str_1, string_utils::to_string(&num_1));
        string::append(&mut str_1,str_2);
        string::append(&mut str_1,string_utils::to_string(&num_2));
        debug::print(&str_1);
    }

    //NOTE
    // vec[i] be not allowed
    // let j = target - vec[i];

    fun sum_of_two(vec:vector<u64>,target:u64):(u64,u64) {
        let index_1 = 0;
        let n = vector::length(&vec);
        debug::print(&n);
        while (index_1 <= n-1) {
            let x = vector::borrow(&vec, index_1);

            // current vec content
            let str_1 = string::utf8(b"index_1 = ");
            let str_2 = string::utf8(b", vector_element = ");
            format_print(str_1,index_1,str_2,*x);

            // continue
            // Subtraction operation will yield a result less than zero,
            // which is not allowed in Move, as Move's integer types are all unsigned.
            // ---> let j = target - *x;

            if ( *x > target){
                index_1 = index_1 + 1;
                continue
            };

            let j = target - *x;
            
            let (is_exit,index_2) = index_of(&vec,&j); 
            debug::print(&is_exit);
            debug::print(&index_2);
            let is_contains = contains(&vec,&j); 
            debug::print(&is_contains);
            if (is_contains && is_exit && index_2 != index_1) {
                return (index_1, index_2)
            };
            index_1 = index_1 + 1;
        };
        return (0, 0)
    }

    #[test]
    fun test(){
        let vec = vector[1,2,3,4,5,6,7,8,9];
        let target = 16;
        let out_vec = vector[];
        let (a,b) =  sum_of_two(vec,target);
        push_back(&mut out_vec,a);
        push_back(&mut out_vec,b);
        debug::print(&mut out_vec);
    }
}
```



- Python

```py
def twoSum(nums: List[int], target: int) -> List[int]:
    for i in range(len(nums)):
        # 获取差
        j = target - nums[i]
        # 如果 j 在 nums 里面，并且 nums 中 j 的索引不是 i
        if j in nums and nums.index(j) is not i:
            return [i,nums.index(j)]
              
if __name__ == "__main__":
    nums = [3,3]
    target = 6
    print(twoSum(nums, target))
```



